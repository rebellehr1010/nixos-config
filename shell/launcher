#!/usr/bin/env bash
#
# gui-launcher.sh
#
# A CLI-only launcher that:
# - Lists all installed GUI apps (by their "Name=" in the .desktop files)
# - Lets you pick one from a fuzzy-searchable list
# - Asks whether to run as normal user or with sudo
#
# Dependencies: fzf, gtk-launch

# 1. Gather all .desktop files from standard locations (use fd for speed)
mapfile -t desktop_files < <(
    fd -L -d 1 -e desktop -t f '.*' \
       /usr/share/applications \
       /usr/local/share/applications \
       "$HOME/.local/share/applications" \
       /run/current-system/sw/share/applications \
       /etc/profiles/per-user/riley/share/applications 2>/dev/null
)

if [ "${#desktop_files[@]}" -eq 0 ]; then
    echo "No .desktop files found"
    exit 1
fi

# --- optional caching layer (insert before building fzf_items) ---
cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/gui-launcher"
cache_file="$cache_dir/desktop_list.txt"
stamp_file="$cache_dir/desktop_stamp"

mkdir -p "$cache_dir"

# Compute a stamp: list of file paths with mtimes. Fast and stable.
current_stamp=$(
    printf '%s\n' "${desktop_files[@]}" |
        xargs -r stat --format='%n:%Y' 2>/dev/null | sort | sha1sum | awk '{print $1}'
)

# Load from cache if stamp matches and cache exists
if [ -f "$cache_file" ] && [ -f "$stamp_file" ] && [ "$(cat "$stamp_file")" = "$current_stamp" ]; then
    mapfile -t fzf_items < "$cache_file"
else
    # Build fzf_items using the fast parser snippet (run the loop above)
    # After building, write to cache
    printf '%s\n' "${fzf_items[@]}" > "$cache_file"
    printf '%s' "$current_stamp" > "$stamp_file"
fi
# --- end caching layer ---


# 2. Build a list of lines: "Name|desktop_id|escaped_info"
# Build fzf_items quickly by parsing each .desktop exactly once with awk
declare -a fzf_items=()
for file_path in "${desktop_files[@]}"; do
    desktop_id=$(basename "$file_path" .desktop)

    # awk extracts the first occurrence of Name (or Name[xx]) and the other keys.
    # It prints a single line: Name|desktop_id|info_with_newlines_escaped
    item_line=$(
        awk -v id="$desktop_id" '
            BEGIN {
                name=""; comment=""; generic=""; exec=""; icon="";
                IGNORECASE=0
            }
            # match keys optionally with locale tag like Name[en_US]=
            /^[[:space:]]*Name([[][^]]+[]])?[[:space:]]*=/ && name=="" {
                sub(/^[^=]*=/,"");
                gsub(/\r$/,"");
                name = $0;
            }
            /^[[:space:]]*Comment([[][^]]+[]])?[[:space:]]*=/ && comment=="" {
                sub(/^[^=]*=/,"");
                gsub(/\r$/,"");
                comment = $0;
            }
            /^[[:space:]]*GenericName([[][^]]+[]])?[[:space:]]*=/ && generic=="" {
                sub(/^[^=]*=/,"");
                gsub(/\r$/,"");
                generic = $0;
            }
            /^[[:space:]]*Exec[[:space:]]*=/ && exec=="" {
                sub(/^[^=]*=/,"");
                gsub(/\r$/,"");
                exec = $0;
            }
            /^[[:space:]]*Icon[[:space:]]*=/ && icon=="" {
                sub(/^[^=]*=/,"");
                gsub(/\r$/,"");
                icon = $0;
            }
            END {
                if (name == "") name = id;
                info = "";
                if (generic != "") info = info "Generic Name: " generic "\n";
                if (comment != "") info = info "Comment: " comment "\n";
                if (icon    != "") info = info "Icon: " icon "\n";
                if (exec    != "") info = info "Exec: " exec "\n";
                # escape literal newlines to \n for safe one-line output
                gsub(/\n/,"\\n", info);
                # strip control chars that might confuse fzf UI
                gsub(/[\x00-\x1F\x7F]/,"", name);
                gsub(/[\x00-\x1F\x7F]/,"", info);
                printf "%s|%s|%s\n", name, id, info;
            }
        ' "$file_path"
    )

    # Only add non-empty lines
    [ -n "$item_line" ] && fzf_items+=("$item_line")
done

# 3. If no entries at all, bail out
if [ "${#fzf_items[@]}" -eq 0 ]; then
    echo "No valid .desktop entries found."
    exit 1
fi

# 4. Use fzf to let the user pick a Name
# --nth=1: Search based on the first field (Name)
# --with-nth=1: Display only the first field (Name) in the list
# --delimiter='|': Use pipe as the field separator
# --preview: Show detailed info for the highlighted entry.
#   '{}' in preview refers to the original full line (Name|desktop_id|info_escaped)
# The output of fzf (with --with-nth=1) will be just the Name.
selection=$(
    printf '%s\n' "${fzf_items[@]}" |
        LC_COLLATE=C sort | # Sort the items alphabetically by Name
        # Clear any global defaults for this fzf call only
        env FZF_DEFAULT_OPTS= \
            fzf --height 40% \
            --layout=reverse \
            --border \
            --prompt="Launch app: " \
            --ansi \
            --delimiter="\|" \
            --with-nth=1 \
            --preview=$'IFS="|" read -r name desktop_id info_escaped <<< "{}"\n\
printf "Desktop ID: %s\\n" "$desktop_id"\n\
printf "Name: %s\\n" "$name"\n\
printf -- "-------------------\\n%b" "${info_escaped}"' |
        # After picking, ensure we only have the Name (field 1)
        # If fzf with --with-nth=1 already outputs only field 1, this cut is benign.
        cut -d"|" -f1
)

# If the user hit ESC or didnâ€™t pick anything, exit cleanly
if [ -z "$selection" ]; then
    exit 0
fi

# 5. Look up the corresponding desktop ID by re-grepping our array using the selected Name
# $selection should be just the Name field.
desktop_id=$(
    printf '%s\n' "${fzf_items[@]}" |
        grep -F "^${selection}|" | # Match the start of the line with "Name|"
        head -n 1 |                # Ensure only one match is processed if names are duplicated
        cut -d"|" -f2
)

# If desktop_id is somehow empty (e.g., selection contained special characters for grep)
if [ -z "$desktop_id" ]; then
    echo "Error: Could not find desktop ID for '$selection'."
    exit 1
fi

# 6. Ask whether to run normally or with sudo
echo
echo "You selected: $selection (ID: $desktop_id)"
echo "  [n] Normal user"
echo "  [s] sudo (root)"
read -r -n1 -p "Run as (n/s)? " mode
echo

# 7. Launch via gtk-launch
if [[ "$mode" =~ ^[sS]$ ]]; then
    echo "Launching '$selection' with sudo..."
    sudo gtk-launch "$desktop_id"
else
    echo "Launching '$selection' as normal user..."
    gtk-launch "$desktop_id"
fi

exit 0
